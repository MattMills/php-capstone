<?php

function collect_enums($filename) {
    $file = fopen(__DIR__.'/capstone/include/capstone/'.$filename, 'r');
    $state = 0;
    $name = null;
    $enums = [];
    $results = [];

    while(!feof($file)) {
        $line = fgets($file);

        switch($state) {
        case 0:
            if (preg_match('/^typedef enum (\w+)/', $line, $match)) {
                $name = $match[1];
                $enums = [];
                $state = 1;
            }
            break;
        case 1:
            if (preg_match('/^} (\w+)/', $line, $match)) {
                $state = 0;
                if ($name != $match[1]) {
                    fprintf(STDERR, "WARNING: unmatch open-close enum %s != %s", $name, $match[1]);
                }
                $results[$name] = $enums;
            } else {
                foreach(explode(",", $line) as $word) {
                    if (preg_match('/^\s*(\w+)/', $word, $match)) {
                        $enums[] = $match[1];
                    }
                    if (strpos($word, "//") !== false) break;
                    if (strpos($word, "/*") !== false) break;
                }
            }
        }
    }
    fclose($file);

    return $results;
}

function collect_defines($filename)
{
    $results = [];

    $file = fopen(__DIR__.'/capstone/include/capstone/'.$filename, 'r');
    while(!feof($file)) {
        $line = fgets($file);

        if (preg_match('/^#define (\w+) (.+)$/', $line, $match)) {
            $results[$match[1]] = $match[2];
        }
    }
    fclose($file);

    return $results;
}


///////////////////////////////////////////////////////////////////////////////
//

$output = fopen(__DIR__.'/const.c', 'w');
fwrite($output, <<<SCRIPT
/* Generated by `genconst.php` */
#include "php_capstone.h"

#define REGISTER_CAPSTONE_CONSTANT(__c) REGISTER_LONG_CONSTANT(#__c, __c, CONST_CS | CONST_PERSISTENT)

void php_capstone_register_constants(int module_number)
{

SCRIPT
);

$header = fopen(__DIR__.'/const.inc', 'w');
fwrite($header, <<<SCRIPT
/* Generated by `genconst.php` */

void php_capstone_register_constants(int);

SCRIPT
);

foreach (collect_enums('capstone.h') as $name=>$enums) {
    fprintf($output, sprintf("// {{{ %s\n", $name));
    foreach($enums as $enum) {
        fprintf($output, "REGISTER_CAPSTONE_CONSTANT(%s);\n", $enum);
    }
    fprintf($output, "// }}} %s\n\n", $name);
}

fwrite($output, <<<SCRIPT
}


SCRIPT
);

///////

foreach (collect_enums('x86.h') as $name=>$enums) {
    // Skip: x86_insn
    if ($name == "x86_insn") continue;

    // Fix: x86_op_type
    $str_len = strlen($name) + 1;
    if ($name == "x86_op_type") $str_len -= 5;

    fprintf($header, sprintf("const char *php_capstone_%s_name(%s);\n", $name, $name));

    fprintf($output, sprintf("const char *php_capstone_%s_name(%s id) {\n", $name, $name));
    fprintf($output, "switch (id) {\n");
    foreach($enums as $enum) {
        $str = substr($enum, $str_len);

        // Skip: INVALID
        if ($str == 'INVALID') continue;

        // Skip: duplicate with X86_PREFIX_REP
        if ($enum == 'X86_PREFIX_REPE') continue;

        // Transform
        $str = strtr(strtolower($str), ["_" => "/"]);

        fprintf($output, "case %s: return \"%s\"; break;\n", $enum, $str);
    }
    fprintf($output, "default: break;\n} // switch\n");
    fprintf($output, "return NULL;\n} // %s\n\n", $name);
}

///////

$eflags_states = ['modify', 'prior', 'reset', 'set', 'test', 'undefined'];
$max = count($eflags_states);

fprintf($header, "void php_capstone_x86_eflags(zval*, uint64_t);\n");
fprintf($output, <<<SCRIPT
void php_capstone_x86_eflags(zval *peflagsob, uint64_t eflags)
{
    zval statesar[$max];

SCRIPT
);

foreach($eflags_states as $idx=>$state) {
    fprintf($output, <<<SCRIPT
    array_init(&statesar[$idx]); // $state

SCRIPT
    );
}

foreach(collect_defines('x86.h') as $name=>$value) {
    if (preg_match('/^X86_EFLAGS_([A-Z]+)_([A-Z]+)/', $name, $match)) {
        $flag = strtolower($match[2]);
        $idx = array_search(strtolower($match[1]), $eflags_states);

        if ($idx === false) continue;

        fprintf($output, <<<SCRIPT
    if (eflags & $name) add_next_index_string(&statesar[$idx], "$flag");

SCRIPT
        );
    }
}

foreach($eflags_states as $idx=>$state) {
    fprintf($output, <<<SCRIPT
    add_property_zval(peflagsob, "$state", &statesar[$idx]);
    zval_ptr_dtor(&statesar[$idx]);

SCRIPT
    );
}

fprintf($output, <<<SCRIPT
}

SCRIPT
);

///////

$fpu_flags_states = ['modify', 'reset', 'set', 'undefined', 'test'];
$max = count($fpu_flags_states);

fprintf($header, "void php_capstone_x86_fpu_flags(zval*, uint64_t);\n");
fprintf($output, <<<SCRIPT
void php_capstone_x86_fpu_flags(zval *pfpu_flagsob, uint64_t fpu_flags)
{
    zval statesar[$max];

SCRIPT
);

foreach($fpu_flags_states as $idx=>$state) {
    fprintf($output, <<<SCRIPT
    array_init(&statesar[$idx]); // $state

SCRIPT
    );
}

foreach(collect_defines('x86.h') as $name=>$value) {
    if (preg_match('/^X86_FPU_FLAGS_([A-Z]+)_([A-Z0-9]+)/', $name, $match)) {
        $flag = strtolower($match[2]);
        $idx = array_search(strtolower($match[1]), $fpu_flags_states);

        if ($idx === false) continue;

        fprintf($output, <<<SCRIPT
    if (fpu_flags & $name) add_next_index_string(&statesar[$idx], "fp$flag");

SCRIPT
        );
    }
}

foreach($fpu_flags_states as $idx=>$state) {
    fprintf($output, <<<SCRIPT
    add_property_zval(pfpu_flagsob, "$state", &statesar[$idx]);
    zval_ptr_dtor(&statesar[$idx]);

SCRIPT
    );
}

fprintf($output, <<<SCRIPT
}

SCRIPT
);

///////

fclose($output);
fclose($header);
